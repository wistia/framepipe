// Generated by CoffeeScript 1.8.0
var frame1, frame2, injectIframe, injectOnePipe, injectTwoIframes, injectTwoPipesDifferentTypes, injectTwoPipesSameType, pipe1, pipe2, testElem, theFrame, thePipe;

testElem = null;

theFrame = null;

frame1 = null;

frame2 = null;

thePipe = null;

pipe1 = null;

pipe2 = null;

injectIframe = function(path) {
  testElem.innerHTML = "<iframe id=\"theframe\" src=\"//differenthost.dev:8454/" + path + "\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"300\" height=\"150\"></iframe>";
  return theFrame = document.getElementById('theframe');
};

injectTwoIframes = function(path1, path2) {
  testElem.innerHTML = "<iframe id=\"frame1\" src=\"//differenthost.dev:8454/" + path1 + "\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"300\" height=\"150\"></iframe>\n<iframe id=\"frame2\" src=\"//differenthost.dev:8454/" + path2 + "\" allowtransparency=\"true\" frameborder=\"0\" scrolling=\"no\" allowfullscreen mozallowfullscreen webkitallowfullscreen oallowfullscreen msallowfullscreen width=\"300\" height=\"150\"></iframe>";
  frame1 = document.getElementById('frame1');
  return frame2 = document.getElementById('frame2');
};

injectOnePipe = function() {
  return injectIframe('OnePipe.html');
};

injectTwoPipesSameType = function() {
  return injectIframe('TwoPipesSameType.html');
};

injectTwoPipesDifferentTypes = function() {
  return injectIframe('TwoPipesDifferentTypes.html');
};

describe('FramePipe', function() {
  beforeEach(function() {
    testElem = document.getElementById('test');
    testElem.innerHTML = '';
    return FramePipe.reset();
  });
  describe('when the outer FramePipe script is initialized after the iframe', function() {
    describe('one pipe', function() {
      beforeEach(function() {
        injectOnePipe();
        return waits(100);
      });
      return describe('onFind', function() {
        it('runs once', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 1;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(1);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            return expect(FramePipe.all().length).toBe(1);
          });
        });
        return describe('when called twice', function() {
          return it('runs twice', function() {
            var thePipes;
            thePipes = [];
            FramePipe.onFind('TestPipe', function(pipe) {
              return thePipes.push(pipe);
            });
            FramePipe.onFind('TestPipe', function(pipe) {
              return thePipes.push(pipe);
            });
            FramePipe.initialize();
            waitsFor(function() {
              return thePipes.length === 2;
            });
            waits(10);
            waitsFor(function() {
              var e;
              try {
                return theFrame.contentWindow;
              } catch (_error) {
                e = _error;
                return false;
              }
            });
            return runs(function() {
              expect(thePipes.length).toBe(2);
              expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
              expect(thePipes[0]).toBe(thePipes[1]);
              return expect(FramePipe.all().length).toBe(1);
            });
          });
        });
      });
    });
    describe('two pipes, same type', function() {
      beforeEach(function() {
        injectTwoPipesSameType();
        return waits(100);
      });
      return describe('onFind', function() {
        return it('runs twice', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[1].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two pipes, different types', function() {
      beforeEach(function() {
        injectTwoPipesDifferentTypes();
        return waits(100);
      });
      return describe('onFind', function() {
        return it('runs once for each type', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe1', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.onFind('TestPipe2', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[1].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[0].pipeType).toBe('TestPipe1');
            expect(thePipes[1].pipeType).toBe('TestPipe2');
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two iframes, one pipe each', function() {
      beforeEach(function() {
        injectTwoIframes('OnePipe.html', 'OnePipe.html');
        return waits(100);
      });
      return describe('onFind', function() {
        return it('runs twice', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two iframes, two pipes each, same types', function() {
      beforeEach(function() {
        injectTwoIframes('TwoPipesSameType.html', 'TwoPipesSameType.html');
        return waits(100);
      });
      return describe('onFind', function() {
        return it('runs four times', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 4;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(4);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[2].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[3].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[1].uid).toNotBe(thePipes[2].uid);
            expect(thePipes[2].uid).toNotBe(thePipes[3].uid);
            return expect(FramePipe.all().length).toBe(4);
          });
        });
      });
    });
    return describe('two iframes, two pipes each, different types', function() {
      beforeEach(function() {
        injectTwoIframes('TwoPipesDifferentTypes.html', 'TwoPipesDifferentTypes.html');
        return waits(100);
      });
      return describe('onFind', function() {
        return it('runs twice for each type', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe1', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.onFind('TestPipe2', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.initialize();
          waitsFor(function() {
            return thePipes.length === 4;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(4);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[2].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[3].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[1].uid).toNotBe(thePipes[2].uid);
            expect(thePipes[2].uid).toNotBe(thePipes[3].uid);
            expect(thePipes[0].pipeType).toBe('TestPipe1');
            expect(thePipes[1].pipeType).toBe('TestPipe2');
            expect(thePipes[2].pipeType).toBe('TestPipe1');
            expect(thePipes[3].pipeType).toBe('TestPipe2');
            return expect(FramePipe.all().length).toBe(4);
          });
        });
      });
    });
  });
  describe('when the outer FramePipe script is initialized before the iframe', function() {
    describe('one pipe', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        it('runs once', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          injectOnePipe();
          waitsFor(function() {
            return thePipes.length === 1;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(1);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            return expect(FramePipe.all().length).toBe(1);
          });
        });
        return describe('when called twice', function() {
          return it('runs twice', function() {
            var thePipes;
            thePipes = [];
            FramePipe.onFind('TestPipe', function(pipe) {
              return thePipes.push(pipe);
            });
            FramePipe.onFind('TestPipe', function(pipe) {
              return thePipes.push(pipe);
            });
            injectOnePipe();
            waitsFor(function() {
              return thePipes.length === 2;
            });
            waits(10);
            waitsFor(function() {
              var e;
              try {
                return theFrame.contentWindow;
              } catch (_error) {
                e = _error;
                return false;
              }
            });
            return runs(function() {
              expect(thePipes.length).toBe(2);
              expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
              expect(thePipes[0]).toBe(thePipes[1]);
              return expect(FramePipe.all().length).toBe(1);
            });
          });
        });
      });
    });
    describe('two pipes, same type', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        return it('runs twice', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          injectTwoPipesSameType();
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[1].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two pipes, different types', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        return it('runs once for each type', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe1', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.onFind('TestPipe2', function(pipe) {
            return thePipes.push(pipe);
          });
          injectTwoPipesDifferentTypes();
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return theFrame.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[1].dstFrame).toBe(theFrame.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[0].pipeType).toBe('TestPipe1');
            expect(thePipes[1].pipeType).toBe('TestPipe2');
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two iframes, one pipe each', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        return it('runs twice', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          injectTwoIframes('OnePipe.html', 'OnePipe.html');
          waitsFor(function() {
            return thePipes.length === 2;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(2);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            return expect(FramePipe.all().length).toBe(2);
          });
        });
      });
    });
    describe('two iframes, two pipes each, same types', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        return it('runs four times', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe', function(pipe) {
            return thePipes.push(pipe);
          });
          injectTwoIframes('TwoPipesSameType.html', 'TwoPipesSameType.html');
          waitsFor(function() {
            return thePipes.length === 4;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(4);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[2].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[3].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[1].uid).toNotBe(thePipes[2].uid);
            expect(thePipes[2].uid).toNotBe(thePipes[3].uid);
            return expect(FramePipe.all().length).toBe(4);
          });
        });
      });
    });
    return describe('two iframes, two pipes each, different types', function() {
      beforeEach(function() {
        return FramePipe.initialize();
      });
      return describe('onFind', function() {
        return it('runs twice for each type', function() {
          var thePipes;
          thePipes = [];
          FramePipe.onFind('TestPipe1', function(pipe) {
            return thePipes.push(pipe);
          });
          FramePipe.onFind('TestPipe2', function(pipe) {
            return thePipes.push(pipe);
          });
          injectTwoIframes('TwoPipesDifferentTypes.html', 'TwoPipesDifferentTypes.html');
          waitsFor(function() {
            return thePipes.length === 4;
          });
          waits(10);
          waitsFor(function() {
            var e;
            try {
              return frame1.contentWindow && frame2.contentWindow;
            } catch (_error) {
              e = _error;
              return false;
            }
          });
          return runs(function() {
            expect(thePipes.length).toBe(4);
            expect(thePipes[0].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[1].dstFrame).toBe(frame1.contentWindow);
            expect(thePipes[2].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[3].dstFrame).toBe(frame2.contentWindow);
            expect(thePipes[0].uid).toNotBe(thePipes[1].uid);
            expect(thePipes[1].uid).toNotBe(thePipes[2].uid);
            expect(thePipes[2].uid).toNotBe(thePipes[3].uid);
            expect(thePipes[0].pipeType).toBe('TestPipe1');
            expect(thePipes[1].pipeType).toBe('TestPipe2');
            expect(thePipes[2].pipeType).toBe('TestPipe1');
            expect(thePipes[3].pipeType).toBe('TestPipe2');
            return expect(FramePipe.all().length).toBe(4);
          });
        });
      });
    });
  });
  return describe('ping', function() {
    describe('one pipe', function() {
      beforeEach(function() {
        FramePipe.initialize();
        injectOnePipe();
        waitsFor(function() {
          return FramePipe.all().length > 0;
        });
        return runs(function() {
          return thePipe = FramePipe.all()[0];
        });
      });
      return it('responds with pong', function() {
        var theMsg;
        expect(thePipe).toBeTruthy();
        thePipe.ping();
        theMsg = null;
        thePipe.listen('pongListener', function(msg) {
          return theMsg = msg;
        });
        waitsFor(function() {
          return theMsg;
        });
        return runs(function() {
          return expect(theMsg).toBe('__pong__');
        });
      });
    });
    return describe('two pipes', function() {
      beforeEach(function() {
        FramePipe.initialize();
        injectTwoPipesSameType();
        waitsFor(function() {
          return FramePipe.all().length === 2;
        });
        return runs(function() {
          var _ref;
          return _ref = FramePipe.all(), pipe1 = _ref[0], pipe2 = _ref[1], _ref;
        });
      });
      return it('each responds with pong from different pipes', function() {
        var msg1, msg2;
        expect(pipe1).toBeTruthy();
        expect(pipe2).toBeTruthy();
        pipe1.ping();
        pipe2.ping();
        msg1 = null;
        msg2 = null;
        pipe1.listen('pongListener', function(msg, full) {
          return msg1 = full;
        });
        pipe2.listen('pongListener', function(msg, full) {
          return msg2 = full;
        });
        waitsFor(function() {
          return msg1 && msg2;
        });
        return runs(function() {
          expect(msg1.message).toBe('__pong__');
          expect(msg2.message).toBe('__pong__');
          return expect(msg1.pipeUid).toNotBe(msg2.pipeUid);
        });
      });
    });
  });
});
